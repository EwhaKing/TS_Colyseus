#  프로젝트 분석 보고서: Snowball Fight

- **프로젝트 명**: Snowball Fight (눈싸움 게임)  
- **GitHub 링크**: [https://github.com/decentraland-scenes/snowball-fight](https://github.com/decentraland-scenes/snowball-fight)

---

##  어떤 게임인지

Snowball Fight는 다수의 플레이어가 눈덩이를 던지며 경쟁하는 멀티플레이어 PvP 게임이다. 실시간 위치 동기화와 충돌 판정, 점수 계산 등이 구현되어 있음.

-주요 기능-
- 실시간 유저 위치 동기화 및 이동
- 눈덩이 생성, 발사, 충돌 판정
- 점수 시스템 및 종료 조건
- PlayFab을 통한 사용자 인증

---

## 🧱 클라이언트/서버 구조 요약

             +-------------------------+
             |     🧍 Client (TS)       |
             |-------------------------|
             | joinOrCreate("arena")   |
             | room.send("throw")      |
             | onStateChange(...)      |
             +-----------▲-------------+
                         |
                WebSocket (Colyseus)
                         |
             +-----------▼-------------+
             |     🖥 Server (TS)       |
             |-------------------------|
             | Colyseus Room 관리      |
             | Schema 상태 업데이트     |
             | 메시지 수신/브로드캐스트 |
             +-------------------------+


- 클라이언트는 Decentraland SDK로 씬을 렌더링하고, Colyseus로 서버와 연결됨.
- 서버는 Colyseus Room 내에서 유저 상태를 관리하고, 동기화된 상태를 전파함. 
---

## Colyseus 사용 방식 요약

### Room 관리  
- `ArenaRoom` 클래스에서 `onCreate`, `onJoin`, `onLeave` 등을 통해 룸 라이프사이클을 제어.
- 하나의 룸에서 여러 플레이어가 동시에 접속해 상호작용.

### 상태 동기화 (State Synchronization)  
- `GameState`, `Player`, `Snowball` 등의 `Schema` 클래스를 통해 구조화된 상태 객체를 정의.
- 이 상태는 서버에서 주기적으로 업데이트되며, 클라이언트는 `onStateChange()`로 이를 수신해 씬을 갱신.

### 메시지 처리 (Message Handling)  
- 클라이언트는 `room.send("throw", {x, y, z})` 와 같이 메시지를 보냄.
- 서버는 `onMessage("throw", handler)` 로 이를 처리하고 게임 상태를 갱신

---

## 수업 개념과 연결되는 부분

- Room 구조: Colyseus에서의 `Room` 클래스는 서버에서 게임 세션 단위로 클라이언트를 그룹화하고, 상태와 메시지를 관리하는 핵심 단위이다. 수업에서 배운 Room은 플레이어들이 공유하는 공간이며, 그 안에서 서버가 주도적으로 동작을 제어하는 구조인데, 이 프로젝트에서 `ArenaRoom`이 정확히 그 역할을 수행함.

- Client–Server 구조: 클라이언트는 눈덩이 발사 등 사용자 입력을 서버에 전달하고, 서버는 이를 처리한 뒤 상태를 갱신해 다시 클라이언트에 전달. 이는 수업에서 배운 **비즈니스 로직은 서버에, 뷰/UI는 클라이언트에** 라는 원칙과 완전히 일치. 클라이언트는 서버의 상태를 수신하고 ECS 엔티티에 반영하는 역할만 하며, 핵심 로직은 모두 서버 `Room` 내에서 처리됨.

- 상태 관리 방식: `Schema`를 이용한 상태 모델은 이때까지 배운 "서버의 상태가 진짜고, 클라이언트는 그걸 따라간다"는 개념과도 직접 연결됨.

## 인상 깊었던 구조/아이디어

- 클라이언트 최소화 설계: 대부분의 로직이 서버에서 처리되고, 클라이언트는 상태 반영만 하도록 설계되어 보안/일관성 측면에서 뛰어나다고 생각함. 

---

##  개인 소감 & 회고

Colyseus는 동시 접속을 처리하고 관리하는 네트워크 중개자이자 서버 프레임워크라는 점을 배울 수 있어 좋았다. 동시 접속이라는 이때까지 써본 툴에서 중요시하지 않은 기능을 메인으로 미는 툴을 써볼 수 있어서, 그리고 그를 활용한 게임을 분석해보는 과정에서 새로운 느낌을 받을 수 있었다.  