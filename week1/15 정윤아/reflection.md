# Week1 - 서버의 개념 정리

## 🌐 서버(Server)

- **제공하는 쪽**. 네트워크를 통해 서비스를 제공하는 시스템.
- 서비스의 종류에 따라 이름이 다름: 웹 서버, 메일 서버, 게임 서버, DB 서버, 파일 서버, 사운드 서버, 프록시 서버 등.
- 서버가 클라이언트의 역할(포지션)이 되기도 함.
- 일반 컴퓨터처럼 생겼지만, 대규모 서비스는 수많은 컴퓨터를 연결한 형태로 구성됨.
- **정의**: 네트워크를 통해 특정 컴퓨터에게 요청을 받고, 그에 대한 응답을 처리하도록 구성된 시스템.

## 🛠 서버의 운용 형태

### 온프레미스 (On-Premise)
- 직접 설비를 보유하여 시스템을 운용·관리
- 구축과 조달에 시간 소요됨
- 구조를 자유롭게 구성 가능
- 트러블 발생 시 직접 원인 파악이 쉬움

### 클라우드 (Cloud)
- AWS, GCP, Azure 등의 서비스 이용
- 설비 구축 시간 거의 없음
- 사업자가 제공하는 설비 범위 내에서만 운영 가능
- 트러블 슈팅이 어려울 수 있음

---

## 🙋‍♀️ 클라이언트(Client)

- **요청하는 쪽**, 서버가 제공하는 서비스를 받는 사용자 혹은 프로그램
- 웹 브라우저 = 클라이언트 (e.g., Chrome, Safari, Firefox 등)
- 클라이언트 머신(아이폰, 노트북 등)과 클라이언트 소프트웨어로 구성됨

> 웹 브라우저에서 사용자가 URL을 요청 → 그 요청을 서버가 처리

---

## 🖥 서버 구성 요소와 관련 기술

| 역할 | 예시 |
|------|------|
| 서버 소프트웨어 | Apache, IIS, Nginx |
| 서버 언어 | PHP, Python, Java |
| 데이터베이스 | MySQL, Oracle 등 |

---

## 📜 정적 웹 vs 동적 웹

- HTML은 정적 웹 문서를 만들 수 있음
- 사용자가 많아지면 정적 웹 페이지로는 한계 발생 → **동적 웹 페이지 필요!**

---

## 🔁 동적 웹의 탄생과 CGI (Common Gateway Interface)

1. 사용자가 웹 브라우저에서 URL 입력
2. 웹 서버는 요청받은 파일의 확장자를 확인함
3. `.html` 파일이면 바로 전송
4. `.php`와 같은 서버 사이드 파일이면 **웹 서버가 직접 처리 못함**
5. 대신, PHP 엔진 같은 프로그램에게 처리를 위임
6. PHP 엔진이 파일을 실행하고 그 결과를 HTML로 돌려줌
7. 웹 서버는 그 HTML을 다시 웹 브라우저에게 전송함

- 브라우저는 HTML만 이해할 수 있음 → **php인지 아닌지 알 수 없음**
- 이 과정에서 CGI는 웹 서버와 외부 엔진(PHP, Python 등) 간의 통신 표준 역할을 함

---

## 💡 CGI의 장점

- 다양한 기술들(PHP, Python, Java 등)을 독립적으로 바꿔 끼울 수 있음
- 프로그램 간 통신의 **표준화**를 통해 유지보수와 확장성이 높아짐

---

## 🧠 PHP란?

- 서버 사이드 스크립트 언어
- 정적인 HTML 파일 대신, **동적인 웹페이지를 자동으로 생성** 가능
- 하나의 PHP 파일로 여러 사용자에게 각기 다른 내용을 보여줄 수 있음

---

## 🧩 OS (Operating System)

- **운영체제(Operating System, OS)**는 하드웨어와 소프트웨어 사이에서 중재자 역할을 하는 시스템 소프트웨어
- 사용자의 명령을 하드웨어가 이해할 수 있도록 바꿔주고, 소프트웨어가 안정적으로 작동하게 돕는 필수 시스템
- 대표적인 OS 종류:
  - Windows, macOS, Linux (데스크탑/노트북)
  - Android, iOS (모바일)
  - Ubuntu, CentOS, Red Hat 등 (서버)

---

## 👨‍💻 클라이언트 vs 서버 개발자의 OS 활용

### 클라이언트 개발자
- 웹 개발자와 애플리케이션 개발자로 나뉨
- 애플리케이션 개발자는 OS별 대응이 필요함 (ex. iOS용 앱, Android용 앱은 따로 만들어야 함)

### 서버 개발자
- 서버는 하나의 프로그램이 OS 위에서 실행됨
- 보통 서버는 **리눅스(Linux)** 위에서 작동함 (안정성 + 비용 효율성 때문)
- macOS는 고가이고 GUI 중심이라 서버 용도로는 비효율적임

> 💬 "서버도 결국 하나의 컴퓨터이며, 그 위에 OS가 존재해야만 동작할 수 있다."

---

## 🧬 OS 독립적인 개발

- 예전에는 OS마다 별도 개발이 필요했음 → 유지보수 어려움
- 현대에는 OS에 독립적인 개발 방식이 대세 (한 번 만들면 어디서든 돌아가게!)
- 대표적 예시: **Java**
  - JVM(Java Virtual Machine) 위에서 실행되므로 OS에 관계없이 작동함
  - 한번 작성하면 모든 플랫폼에서 실행 가능: "Write once, run anywhere"

---

## 🔁 API와 서버 응답 흐름

- 서버는 클라이언트의 다양한 요청을 처리하고, 그에 맞는 응답을 보내는 프로그램
- 클라이언트는 웹, 앱 등 다양한 형태로 서버에 요청을 보냄
- 서버는 **기능별 요청을 구분**하고 **적절한 응답을 보냄**
- 이때 "요청과 응답 간의 규약"을 정리해 놓은 문서가 **API 문서**

### 📄 API 문서란?
> 프로그램의 특정 기능이 어떻게 작동하는지 정리해 놓은 문서  
> - 요청 (Request): 요청할 때 어떤 데이터가 필요한지
> - 응답 (Response): 응답에는 어떤 데이터가 담겨 있는지  
> - 예: 로그인 API  
>   - 요청: username, password  
>   - 응답: access token, user id

---

## 🧑‍💻 프론트엔드 vs 백엔드

| 구분 | 설명 |
|------|------|
| 프론트엔드(Frontend) | 클라이언트 프로그램 개발자. 웹이든 앱이든 사용자가 직접 보게 되는 UI 개발 담당 |
| 백엔드(Backend) | 서버 개발자. 사용자 요청을 처리하고, DB 연동, 비즈니스 로직을 처리하는 시스템 구축 담당 |

---

## 🧱 라이브러리 (Library)

> 내가 필요할 때 **내가 호출해서** 사용하는 도구

- 개발자가 주도권을 가짐 (내 코드가 주도)
- 특정 기능이 필요할 때 꺼내 쓰는 도구 느낌
- 내가 원하는 방식대로 코드를 구성하고, 라이브러리는 기능만 보조해주는 역할
- 자유롭고 유연하지만 통일된 구조는 없음

**📌 예시**:  
- `jQuery`: HTML 요소 선택, 애니메이션 처리 등 DOM 제어에 특화된 JS 라이브러리
- `Lodash`: 배열, 객체 등 JS 데이터 처리 기능 강화
- `ReactJS`: UI를 컴포넌트화해서 관리할 수 있는 라이브러리 (하지만 구조화된 방식 덕분에 종종 프레임워크처럼 쓰이기도!)

---

## 🏗 프레임워크 (Framework)

> 나는 **프레임워크가 호출하는 입장**, 즉 규칙을 따라야 하는 구조

- 개발자가 주도권을 일부 넘겨줌 (프레임워크가 구조와 흐름을 정함)
- "어디에 코드를 넣을지" 정해져 있고, 그 틀에 맞춰 개발함
- 강력한 기능 제공 + 일관된 구조 → 빠르고 안정적인 개발 가능
- 대신, 구조에 대한 이해가 부족하면 진입 장벽이 높음

**📌 예시**:  
- `Django`: Python 기반 웹 프레임워크. MVC(MTV) 구조가 뚜렷함.
- `Angular`: 구글이 만든 프론트엔드 프레임워크
- `NestJS`: 백엔드용 TypeScript 프레임워크. Express 기반.

## 🎮 Colyseus Multiplayer Framework란?

> Colyseus는 **JavaScript/TypeScript + Node.js** 환경에서 **멀티플레이어 게임 서버를 구축**할 수 있게 해주는 오픈소스 프레임워크!

- 서버와 클라이언트 간 상태 동기화(State Sync)를 **자동화**해주고
- 클라이언트가 룸(Room)에 쉽게 매칭되도록 도와주는 기능 제공
- 프론트엔드나 Unity, Godot 등 **게임 엔진과 쉽게 연동 가능**

### 🌟 주요 특징 요약

- 👥 **Match-making into Rooms**  
  → 하나의 Room 정의만으로 여러 클라이언트가 자동으로 해당 Room 인스턴스에 매칭됨

- 🔁 **State Synchronization**  
  → 서버에서 클라이언트로 상태 정보를 자동 동기화! (게임에서 유닛 위치, 체력 같은 정보가 실시간으로 동기화됨)

- 📈 **Scalable (확장성)**  
  → 수평/수직적 확장이 가능하게 설계되어 큰 규모의 게임 서비스도 대응 가능

- ☁ **Cloud agnostic**  
  → 자유롭게 자체 서버에 호스팅 가능하고, 상용 서비스인 [Colyseus Cloud]도 사용 가능

---

## 🧾 Node.js란?

> **자바스크립트를 브라우저 밖, 즉 서버에서도 실행할 수 있게 해주는 런타임 환경**

### ✨ Node.js의 핵심 기능

- 원래 JS는 웹 브라우저 안에서만 동작했는데, Node.js 덕분에 서버에서도 사용할 수 있게 됨
- **V8 엔진** 기반 (크롬 브라우저에서 쓰는 JS 엔진)
- 비동기 I/O, 이벤트 기반 구조 → 서버에서 많은 클라이언트를 동시에 처리하는 데 최적화됨
- 파일 읽기/쓰기, 네트워크 요청 처리, 데이터베이스 접근 등 서버 작업 가능

### 💡 Node.js의 장점

- 프론트엔드와 백엔드 모두 **같은 언어(JS/TS)**로 개발 가능 → 개발 효율성 증가!
- 속도가 빠르고 확장성이 뛰어나서 **실시간 채팅, 게임 서버, REST API** 개발에 많이 사용됨

---


📁 작성자: 정윤아  
📅 Week1 - 서버 기본 개념 정리
